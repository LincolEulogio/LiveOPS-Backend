generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

model User {
  id       String  @id @default(uuid()) @db.Uuid
  email    String  @unique
  password String
  name     String?

  // Relations
  sessions    Session[]
  productions ProductionUser[]
  auditLogs   AuditLog[]

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Soft Delete
  deletedAt        DateTime?
  deviceSessions   DeviceSession[]
  commands         Command[]         @relation("CommandSender")
  commandResponses CommandResponse[]

  // Performance Indexes
  @@index([email])
  @@index([deletedAt])
}

model Role {
  id          String  @id @default(uuid()) @db.Uuid
  name        String  @unique // e.g., 'ADMIN', 'OPERATOR', 'VIEWER'
  description String?

  // Relations
  permissions RolePermission[]
  users       ProductionUser[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  commands  Command[]
}

model VmixConnection {
  id           String  @id @default(uuid()) @db.Uuid
  productionId String  @unique @db.Uuid
  url          String // usually http://127.0.0.1:8088
  isEnabled    Boolean @default(true)

  production Production @relation(fields: [productionId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum BlockStatus {
  PENDING
  ACTIVE
  COMPLETED
}

model TimelineBlock {
  id                 String      @id @default(uuid()) @db.Uuid
  productionId       String      @db.Uuid
  title              String
  description        String?
  durationMs         Int         @default(0) // 0 means manual trigger
  status             BlockStatus @default(PENDING)
  order              Int         @default(0)
  linkedScene        String? // e.g., name of OBS/vMix scene
  intercomTemplateId String?     @db.Uuid // Optional auto-command
  startTime          DateTime?
  endTime            DateTime?

  production       Production       @relation(fields: [productionId], references: [id], onDelete: Cascade)
  intercomTemplate CommandTemplate? @relation(fields: [intercomTemplateId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([productionId])
}

model Permission {
  id          String  @id @default(uuid()) @db.Uuid
  action      String  @unique // e.g., 'production:create', 'scene:switch'
  description String?

  // Relations
  roles RolePermission[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model RolePermission {
  roleId       String @db.Uuid
  permissionId String @db.Uuid

  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@id([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
}

model Production {
  id          String  @id @default(uuid()) @db.Uuid
  name        String
  description String?
  status      String  @default("DRAFT") // DRAFT, LIVE, FINISHED

  // Relations
  users ProductionUser[]

  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  deletedAt        DateTime?
  deviceSessions   DeviceSession[]
  commandTemplates CommandTemplate[]
  commands         Command[]
  obsConnection    ObsConnection?
  vmixConnection   VmixConnection?
  timelineBlocks   TimelineBlock[]

  @@index([status])
  @@index([deletedAt])
}

model ProductionUser {
  userId       String @db.Uuid
  productionId String @db.Uuid
  roleId       String @db.Uuid

  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  production Production @relation(fields: [productionId], references: [id], onDelete: Cascade)
  role       Role       @relation(fields: [roleId], references: [id], onDelete: Restrict)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@id([userId, productionId])
  @@index([userId])
  @@index([productionId])
}

model Session {
  id           String   @id @default(uuid()) @db.Uuid
  userId       String   @db.Uuid
  refreshToken String   @unique
  expiresAt    DateTime
  isRevoked    Boolean  @default(false)
  ipAddress    String?
  userAgent    String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([refreshToken])
}

model AuditLog {
  id        String  @id @default(uuid()) @db.Uuid
  userId    String? @db.Uuid
  action    String
  details   Json?
  ipAddress String?

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([action])
}

model DeviceSession {
  id             String    @id @default(uuid()) @db.Uuid
  socketId       String    @unique
  userId         String    @db.Uuid
  productionId   String    @db.Uuid
  isOnline       Boolean   @default(true)
  connectedAt    DateTime  @default(now())
  disconnectedAt DateTime?

  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  production Production @relation(fields: [productionId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([productionId])
  @@index([isOnline])
}

model CommandTemplate {
  id           String  @id @default(uuid()) @db.Uuid
  productionId String  @db.Uuid
  name         String // e.g. "Standby Camera 1", "Cut to Black"
  description  String?
  icon         String?
  color        String?

  production Production @relation(fields: [productionId], references: [id], onDelete: Cascade)
  commands   Command[]

  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  timelineBlocks TimelineBlock[]

  @@index([productionId])
}

model Command {
  id           String  @id @default(uuid()) @db.Uuid
  productionId String  @db.Uuid
  senderId     String  @db.Uuid
  targetRoleId String? @db.Uuid // If null, it's a broadcast
  templateId   String? @db.Uuid
  message      String // The actual text sent
  requiresAck  Boolean @default(true)
  status       String  @default("SENT") // SENT, DELIVERED, COMPLETED

  production Production        @relation(fields: [productionId], references: [id], onDelete: Cascade)
  sender     User              @relation("CommandSender", fields: [senderId], references: [id], onDelete: Cascade)
  targetRole Role?             @relation(fields: [targetRoleId], references: [id], onDelete: SetNull)
  template   CommandTemplate?  @relation(fields: [templateId], references: [id], onDelete: SetNull)
  responses  CommandResponse[]

  createdAt DateTime @default(now())

  @@index([productionId])
  @@index([senderId])
  @@index([targetRoleId])
}

model CommandResponse {
  id          String  @id @default(uuid()) @db.Uuid
  commandId   String  @db.Uuid
  responderId String  @db.Uuid
  response    String // e.g. "OK", "PROBLEM", "STANDBY"
  note        String?

  command   Command @relation(fields: [commandId], references: [id], onDelete: Cascade)
  responder User    @relation(fields: [responderId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([commandId])
  @@index([responderId])
}

model ObsConnection {
  id           String  @id @default(uuid()) @db.Uuid
  productionId String  @unique @db.Uuid
  url          String // usually ws://127.0.0.1:4455
  password     String?
  isEnabled    Boolean @default(true)

  production Production @relation(fields: [productionId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
